{
  "version": "0.0.6",
  "sources": {
    "@arianee/contracts/Interfaces/ICreditManager.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.18;\n\ninterface ICreditManager {\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    event CreditBought(\n        address indexed buyer,\n        address indexed _receiver,\n        address indexed _contract,\n        uint256 quantity\n    );\n    event CreditConsumed(address indexed _spender, address indexed _contract);\n    event DispatchRewardChanged(\n        uint8 _percentInfra,\n        uint8 _percentCreatorProvider,\n        uint8 _percentConsumerProvider,\n        uint8 _percentArianeeProject,\n        uint8 _percentFirstOwner\n    );\n    event Initialized(uint8 version);\n    event NewAriaUsdExchangeRate(uint256 _ariaUsdExchangeRate);\n    event NewCreditPriceUsd(address _contract, uint256 _creditPriceUsd);\n    event NewExchangeModifier(address _exchangeModifier);\n    event NewInfraAddress(address _newInfraAddress);\n    event NewProtocolAddress(address _newProtocolAddress);\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event Upgraded(address indexed implementation);\n\n    function acceptedToken() external view returns (address);\n\n    function ariaUsdExchangeRate() external view returns (uint256);\n\n    function balanceOf(\n        address _creditOwner,\n        address _contract\n    ) external view returns (uint256);\n\n    function buyCredit(\n        address _contract,\n        uint256 _quantity,\n        address _receiver\n    ) external;\n\n    function consumeCredit(\n        address _spender,\n        address _creatorProvider,\n        address _consumerProvider,\n        address _firstOwner\n    ) external;\n\n    function creditPriceUSD(address) external view returns (uint256);\n\n    function dispatchPercent(uint256) external view returns (uint256);\n\n    function exchangeModifier() external view returns (address);\n\n    function getCreditPriceUsd(\n        address _contract\n    ) external view returns (uint256);\n\n    function infraAddress() external view returns (address);\n\n    function initialize(\n        address _exchangeModifier,\n        address _acceptedToken\n    ) external;\n\n    function isTrustedForwarder(address forwarder) external view returns (bool);\n\n    function owner() external view returns (address);\n\n    function protocolAddress() external view returns (address);\n\n    function proxiableUUID() external view returns (bytes32);\n\n    function renounceOwnership() external;\n\n    function setAriaUsdExchangeRate(uint256 _ariaUsdExchangeRate) external;\n\n    function setCreditPriceUsd(\n        address _contract,\n        uint256 _creditPriceUsd\n    ) external;\n\n    function setDispatchPercent(\n        uint8 _percentInfra,\n        uint8 _percentCreatorProvider,\n        uint8 _percentConsumerProvider,\n        uint8 _percentArianeeProject,\n        uint8 _percentFirstOwner\n    ) external;\n\n    function setExchangeModifier(address _exchangeModifier) external;\n\n    function setInfraAddress(address _newInfraAddress) external;\n\n    function setProtocolAddress(address _newProtocolAddress) external;\n\n    function transferOwnership(address newOwner) external;\n\n    function upgradeTo(address newImplementation) external;\n\n    function upgradeToAndCall(\n        address newImplementation,\n        bytes memory data\n    ) external payable;\n}\n",
    "@arianee/contracts/Interfaces/IRulesManager.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.18;\n\ninterface IRulesManager {\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    event Initialized(uint8 version);\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event RoleAdminChanged(\n        bytes32 indexed role,\n        bytes32 indexed previousAdminRole,\n        bytes32 indexed newAdminRole\n    );\n    event RoleGranted(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n    event RoleRevoked(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n    event TokenEventGlobalAllowlistUpdated(\n        address indexed tokenAddress,\n        address sender,\n        address[] addresses,\n        bool allowed\n    );\n    event TokenFeaturesUpdated(\n        address indexed tokenAddress,\n        bool msgEnabled,\n        bool eventEnabled\n    );\n    event TokenMsgGlobalAllowlistUpdated(\n        address indexed tokenAddress,\n        address sender,\n        address[] addresses,\n        bool allowed\n    );\n    event TokenMsgPerTokenAllowlistUpdated(\n        address indexed tokenAddress,\n        uint256 indexed tokenId,\n        address sender,\n        address indexed owner,\n        address[] addresses,\n        bool allowed\n    );\n    event TokenMsgPerTokenBlacklistUpdated(\n        address indexed tokenAddress,\n        uint256 indexed tokenId,\n        address sender,\n        address indexed owner,\n        address[] addresses,\n        bool allowed\n    );\n    event TrustedForwarderSet(\n        address indexed previousForwarder,\n        address indexed newForwarder\n    );\n    event Upgraded(address indexed implementation);\n\n    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);\n\n    function MSG_PER_TOKEN_WHITELIST_MANAGER() external view returns (bytes32);\n\n    function addEventGlobalAllowlist(\n        address tokenAddress,\n        address[] memory addresses\n    ) external;\n\n    function addMsgGlobalAllowlist(\n        address tokenAddress,\n        address[] memory addresses\n    ) external;\n\n    function addMsgPerTokenAllowlist(\n        address tokenAddress,\n        uint256 tokenId,\n        address[] memory addresses\n    ) external;\n\n    function addMsgPerTokenBlacklist(\n        address tokenAddress,\n        uint256 tokenId,\n        address[] memory addresses\n    ) external;\n\n    function eventGlobalAllowlist(\n        address,\n        address\n    ) external view returns (bool);\n\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    function grantRole(bytes32 role, address account) external;\n\n    function hasRole(\n        bytes32 role,\n        address account\n    ) external view returns (bool);\n\n    function initialize(address trustedForwarder_) external;\n\n    function isAllowedEventEmitter(\n        address tokenAddress,\n        address sender\n    ) external view returns (bool);\n\n    function isAllowedMsgSender(\n        address tokenAddress,\n        uint256 tokenId,\n        address sender\n    ) external view returns (bool);\n\n    function isTrustedForwarder(address forwarder) external view returns (bool);\n\n    function msgGlobalAllowlist(address, address) external view returns (bool);\n\n    function owner() external view returns (address);\n\n    function proxiableUUID() external view returns (bytes32);\n\n    function removeEventGlobalAllowlist(\n        address tokenAddress,\n        address[] memory addresses\n    ) external;\n\n    function removeMsgGlobalAllowlist(\n        address tokenAddress,\n        address[] memory addresses\n    ) external;\n\n    function removeMsgPerTokenAllowlist(\n        address tokenAddress,\n        uint256 tokenId,\n        address[] memory addresses\n    ) external;\n\n    function removeMsgPerTokenBlacklist(\n        address tokenAddress,\n        uint256 tokenId,\n        address[] memory addresses\n    ) external;\n\n    function renounceOwnership() external;\n\n    function renounceRole(bytes32 role, address account) external;\n\n    function revokeRole(bytes32 role, address account) external;\n\n    function setTrustedForwarder(address trustedForwarder) external;\n\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    function toggleFeatures(\n        address tokenAddress,\n        bool msgEnabled,\n        bool eventEnabled\n    ) external;\n\n    function tokenToTokenRules(\n        address\n    )\n        external\n        view\n        returns (bool msgEnabled, bool eventEnabled, bool eventAllowlistActive);\n\n    function transferOwnership(address newOwner) external;\n\n    function upgradeTo(address newImplementation) external;\n\n    function upgradeToAndCall(\n        address newImplementation,\n        bytes memory data\n    ) external payable;\n}\n",
    "@arianee/contracts/SmartAsset/SmartAssetBase.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"../Utilities/MutableERC2771Context.sol\";\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../Interfaces/ICreditManager.sol\";\nimport \"../Interfaces/IRulesManager.sol\";\n\n/**\n * @title SmartAssetBase.\n * @author Arianee - Dynamic NFTs for real-world use cases and consumer engagement (www.arianee.org).\n */\nabstract contract SmartAssetBase is Ownable, MutableERC2771Context, Pausable, AccessControl, ERC721, ERC721Enumerable {\n    /**\n     * @notice PAUSER_ROLE: those who can pause the contract in case of emergency.\n     */\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @notice MINTER_ROLE: those who can mint or hydrate tokens.\n     */\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    /**\n     * @notice Rules manager contract used for event authorization.\n     * Rules are managed by globally by token contract owner and on a per-token basis by token owners.\n     */\n    IRulesManager public rulesManager;\n\n    /**\n     * @notice Credit manager contract used for credit consumption.\n     */\n    ICreditManager public creditManager;\n\n    /**\n     * @notice Parameters for hydrating a token. See {SmartAssetBase-hydrateToken}.\n     * @param tokenId The token ID.\n     * @param imprint The token imprint.\n     * @param viewKey The token initial view key.\n     * @param transferKey The token initial transfer key (optional).\n     * @param issuer The token issuer.\n     * @param otherParams An array of bytes that can be used by child contracts if any to gather additional parameters. Its construction depends on your SmartAsset inheritance graph.\n     */\n    struct TokenHydratationParams {\n        uint256 tokenId;\n        bytes32 imprint;\n        address viewKey;\n        address transferKey;\n        address creatorProvider;\n        bytes[] otherParams;\n    }\n\n    /**\n     * @notice Footprint of a token. See {SmartAssetBase-idToFootprint}.\n     */\n    struct TokenFootprint {\n        address issuer;\n        uint256 creationTimestamp;\n    }\n\n    /**\n     * @notice Providers of a token\n     * @param creatorProvider is the address that will be rewarded for creating the token\n     * @param creatorProvider is the address that will be rewarded for claiming the token\n     */\n    struct TokenProviders {\n        address creatorProvider;\n        address walletProvider;\n    }\n\n    /**\n     * @notice Mapping from token id to its footprint. See {TokenFootprint}.\n     */\n    mapping(uint256 => TokenFootprint) internal idToFootprint;\n\n    /**\n     * @notice Mapping from token id to its imprint.\n     */\n    mapping(uint256 => bytes32) internal idToImprint;\n\n    /**\n     * @notice Mapping from token id to a boolean that indicates whether the first transfer has been done or not.\n     */\n    mapping(uint256 => bool) internal idToFirstTransfer;\n\n    /**\n     * @notice Mapping from token id to its view key.\n     */\n    mapping(uint256 => address) internal idToViewKey;\n\n    /**\n     * @notice Mapping from token id to its transfer key.\n     */\n    mapping(uint256 => address) internal idToTransferKey;\n\n    /**\n     * @notice Mapping from token id to its providers.\n     */\n    mapping(uint256 => TokenProviders) internal tokenProviders;\n\n    /**\n     * @notice This emits when a token is hydrated.\n     */\n    event TokenHydrated(\n        uint256 indexed tokenId,\n        bytes32 indexed imprint,\n        address viewKey,\n        address transferKey,\n        uint256 creationDate\n    );\n\n    /**\n     * @notice This emits when a token view access is added.\n     */\n    event TokenViewAccessAdded(uint256 indexed tokenId, address key);\n\n    /**\n     * @notice This emits when a token view access is removed.\n     */\n    event TokenViewAccessRemoved(uint256 indexed tokenId);\n\n    /**\n     * @notice This emits when a token transfer access is added.\n     */\n    event TokenTransferAccessAdded(uint256 indexed tokenId, address key);\n\n    /**\n     * @notice This emits when a token transfer access is removed.\n     */\n    event TokenTransferAccessRemoved(uint256 indexed tokenId);\n\n    constructor(string memory name_, string memory symbol_, address rulesManagerAddress_, address creditManagerAddress_, address trustedForwarder_) MutableERC2771Context(trustedForwarder_) ERC721(name_, symbol_) {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(PAUSER_ROLE, msg.sender);\n        rulesManager = IRulesManager(rulesManagerAddress_);\n        creditManager = ICreditManager(creditManagerAddress_);\n    }\n\n    /**\n     * @notice Check if `spender` is approved or owner of `tokenId`.\n     */\n    modifier isApprovedOrOwner(address spender, uint256 tokenId) {\n        require(_isApprovedOrOwner(spender, tokenId), \"SmartAssetBase: The caller is not owner nor approved\");\n        _;\n    }\n\n    /**\n     * @notice Check if `_msgSender()` is the issuer of `tokenId`.\n     */\n    modifier isIssuer(uint256 tokenId) {\n        require(_msgSender() == idToFootprint[tokenId].issuer, \"SmartAssetBase: The caller is not the issuer\");\n        _;\n    }\n\n    /**\n     * @notice Reserve a token with a specific ID for a given address.\n     * @dev It is equivalent to mint a token with a specific ID for a given address.\n     * @param to The address that will own the minted token.\n     * @param tokenId The desired token ID.\n     */\n    function reserveToken(address to, uint256 tokenId) public onlyRole(MINTER_ROLE) whenNotPaused {\n        super._safeMint(to, tokenId);\n        idToFirstTransfer[tokenId] = true;\n    }\n\n    /**\n     * @notice Hydrate a specific pre-reserved token.\n     * @param tokenHydratationParams The token hydratation parameters. See {TokenHydratationParams}.\n     */\n    function hydrateToken(\n        TokenHydratationParams memory tokenHydratationParams\n    ) public virtual onlyRole(MINTER_ROLE) whenNotPaused {\n        uint256 tokenId = tokenHydratationParams.tokenId;\n\n        if(!_exists(tokenId)) {\n            reserveToken(_msgSender(), tokenId);\n        }\n        \n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"SmartAssetBase: The caller is not owner nor approved\");\n\n        TokenFootprint storage existingFootprint = idToFootprint[tokenId];\n        require(existingFootprint.creationTimestamp == 0, \"SmartAssetBase: This token has already been hydrated\");\n\n        uint256 creationTimestamp = block.timestamp;\n        TokenFootprint memory newFootprint = TokenFootprint({\n            creationTimestamp: creationTimestamp,\n            issuer: _msgSender()\n        });\n        idToFootprint[tokenId] = newFootprint;\n\n        setTokenViewKey(tokenId, tokenHydratationParams.viewKey);\n        if (tokenHydratationParams.transferKey != address(0)) {\n            setTokenTransferKey(tokenId, tokenHydratationParams.transferKey);\n        }\n\n        idToImprint[tokenId] = tokenHydratationParams.imprint;\n\n        tokenProviders[tokenId] = TokenProviders({\n            creatorProvider: tokenHydratationParams.creatorProvider,\n            walletProvider: tokenHydratationParams.creatorProvider\n        });\n\n        emit TokenHydrated(\n            tokenId,\n            tokenHydratationParams.imprint,\n            tokenHydratationParams.viewKey,\n            tokenHydratationParams.transferKey,\n            creationTimestamp\n        );\n    }\n\n\n    function getViewKey(uint256 tokenId) public view returns (address) {\n        return idToViewKey[tokenId];\n    }\n\n    function getTransferKey(uint256 tokenId) public view returns (address) {\n        return idToTransferKey[tokenId];\n    }\n\n    /**\n     * @notice Transfer a given token to a new owner. This function is only callable by someone who give a valid signature according to the token transfer key.\n     * @param tokenId The token ID.\n     * @param signature An envelope of `keccak256(abi.encode(tokenId, newOwner))` signed by the private key matching the token transfer key.\n     * @param newOwner The new owner of the token.\n     * @param keepTransferKey A flag to indicate if the transfer key should be kept or not.\n     */\n    function requestToken(\n        uint256 tokenId,\n        bytes calldata signature,\n        address newOwner,\n        bool keepTransferKey,\n        address walletProvider\n    ) public virtual whenNotPaused {\n        bytes32 message = keccak256(abi.encode(tokenId, newOwner));\n        bytes32 messageHash = ECDSA.toEthSignedMessageHash(message);\n        require(\n            ECDSA.recover(messageHash, signature) == idToTransferKey[tokenId],\n            \"SmartAssetBase: The signature does not match current token transfer key\"\n        );\n\n        if (!keepTransferKey) {\n            _setTokenTransferKey(tokenId, address(0));\n        }\n\n        super._approve(_msgSender(), tokenId);\n\n        address owner = super.ownerOf(tokenId);\n\n        tokenProviders[tokenId].walletProvider = walletProvider;\n\n        super.safeTransferFrom(owner, newOwner, tokenId);\n    }\n\n    /**\n     * @notice Set the view key for a given token.\n     * @param tokenId The token ID.\n     * @param key The view key.\n     */\n    function setTokenViewKey(\n        uint256 tokenId,\n        address key\n    ) public virtual isApprovedOrOwner(_msgSender(), tokenId) whenNotPaused {\n        _setTokenViewKey(tokenId, key);\n    }\n\n    /**\n     * @notice Set the view key for a given token.\n     * @param tokenId The token ID.\n     * @param key The view key.\n     */\n    function setTokenTransferKey(\n        uint256 tokenId,\n        address key\n    ) public virtual isApprovedOrOwner(_msgSender(), tokenId) whenNotPaused {\n        _setTokenTransferKey(tokenId, key);\n    }\n\n    /**\n     * @notice Pauses all transfers.\n     */\n    function pause() public onlyRole(PAUSER_ROLE) {\n        _pause();\n    }\n\n    /**\n     * @notice Unpauses all transfers.\n     */\n    function unpause() public onlyRole(PAUSER_ROLE) {\n        _unpause();\n    }\n\n    /**\n     * @notice Check if a token is requestable.\n     * @dev Throws if the token is not minted.\n     * @param tokenId The token ID.\n     * @return A boolean indicating if the token is requestable.\n     */\n    function isRequestable(uint256 tokenId) public view returns (bool) {\n        _requireMinted(tokenId);\n        return idToTransferKey[tokenId] != address(0);\n    }\n\n    /**\n     * @notice Try to retrieve the TokenFootprint of a given token.\n     * @dev Throws if the token is not minted.\n     * @param tokenId The token ID.\n     * @return The TokenFootprint of the token if any.\n     */\n    function footprintOf(uint256 tokenId) public view returns (TokenFootprint memory) {\n        _requireMinted(tokenId);\n        return idToFootprint[tokenId];\n    }\n\n\n    /**\n     * @notice Try to retrieve the issuer of a given token.\n     * @dev Throws if the token is not minted.\n     * @param tokenId The token ID.\n     * @return issuer of the token if any.\n     */\n    function issuerOf(uint256 tokenId) public view returns (address issuer){\n        _requireMinted(tokenId);\n        return idToFootprint[tokenId].issuer;\n    }\n\n    /**\n     * @notice Try to retrieve the imprint of a given token.\n     * @dev Throws if the token is not minted.\n     * @param tokenId The token ID.\n     * @return The imprint of the token if any.\n     */\n    function imprintOf(uint256 tokenId) public view returns (bytes32) {\n        _requireMinted(tokenId);\n        return idToImprint[tokenId];\n    }\n\n    /**\n     * @notice Flag indicating if this contract is shared by multiple issuers or not.\n     * @dev This is mostly used by off-chain sync services.\n     * @return False unless explicitly overridden.\n     */\n    function isShared() public pure virtual returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC721, ERC721Enumerable, AccessControl) returns (bool) {\n        return interfaceId == type(SmartAssetBase).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @notice Internal function to set the view key for a given token.\n     * As opposed to {setTokenViewKey}, this imposes no restrictions on _msgSender().\n     */\n    function _setTokenViewKey(uint256 tokenId, address key) internal {\n        _requireMinted(tokenId);\n\n        idToViewKey[tokenId] = key;\n        if (key != address(0)) {\n            emit TokenViewAccessAdded(tokenId, key);\n        } else {\n            emit TokenViewAccessRemoved(tokenId);\n        }\n    }\n\n    /**\n     * @notice Internal function to set the transfer key for a given token.\n     * As opposed to {setTokenTransferKey}, this imposes no restrictions on _msgSender().\n     */\n    function _setTokenTransferKey(uint256 tokenId, address key) internal {\n        _requireMinted(tokenId);\n\n        idToTransferKey[tokenId] = key;\n        if (key != address(0)) {\n            emit TokenTransferAccessAdded(tokenId, key);\n        } else {\n            emit TokenTransferAccessRemoved(tokenId);\n        }\n    }\n\n    /**\n     * @dev See {ERC721-_transfer}\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual override {\n        super._transfer(from, to, tokenId);\n\n        if (_isFirstTokenTransfer(tokenId)) {\n            idToFirstTransfer[tokenId] = false;\n            _afterFirstTokenTransfer(tokenId);\n        }\n    }\n\n    /**\n     * @dev Hook that is called before first token transfer.\n     */\n    function _afterFirstTokenTransfer(uint256 tokenId) internal virtual {\n        creditManager.consumeCredit(\n            idToFootprint[tokenId].issuer,\n            tokenProviders[tokenId].creatorProvider,\n            tokenProviders[tokenId].walletProvider,\n            super.ownerOf(tokenId)\n        );\n    }\n\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 batchSize\n    ) internal virtual override(ERC721, ERC721Enumerable) whenNotPaused {\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n\n    /**\n     * @notice Authorize the issuer to send messages to the new owner\n     * @dev See {ERC721-_afterTokenTransfer}.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 batchSize\n    ) internal virtual override(ERC721) {\n        if (to != address(0)) { \n            address issuer = idToFootprint[tokenId].issuer;\n            if (to != issuer && !rulesManager.isAllowedMsgSender(address(this), tokenId, issuer)){\n                address[] memory addresses = new address[](1);\n                addresses[0] = issuer;\n                rulesManager.addMsgPerTokenAllowlist(address(this), tokenId, addresses);\n            }\n        }\n\n        super._afterTokenTransfer(from, to, tokenId, batchSize);\n    }\n\n    /**\n     * @notice Check if a token has already been transferred.\n     * @param tokenId The token ID.\n     */\n    function _isFirstTokenTransfer(uint256 tokenId) internal view returns (bool) {\n        return idToFirstTransfer[tokenId] == true;\n    }\n\n    /**\n     * @dev See {MutableERC2771Context-_msgSender}.\n     */\n    function _msgSender() internal override(MutableERC2771Context, Context) virtual view returns (address) {\n        return MutableERC2771Context._msgSender();\n    }\n\n    /**\n     * @dev See {MutableERC2771Context-_msgData}.\n     */\n    function _msgData() internal override(MutableERC2771Context, Context) virtual view returns (bytes calldata) {\n        return MutableERC2771Context._msgData();\n    }\n}\n",
    "@arianee/contracts/SmartAsset/SmartAssetBurnable.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport \"./SmartAssetBase.sol\";\n\n/**\n * @title SmartAssetBurnable.\n * @author Arianee - Dynamic NFTs for real-world use cases and consumer engagement (www.arianee.org).\n */\nabstract contract SmartAssetBurnable is SmartAssetBase {\n    /**\n     * @notice This emits when a token is burned.\n     */\n    event TokenBurned(uint256 indexed tokenId);\n\n    function burn(uint256 tokenId) external virtual whenNotPaused {\n        require(super._isApprovedOrOwner(_msgSender(), tokenId), \"SmartAssetBurnable: caller is not token owner or approved\");\n\n        super._burn(tokenId);\n\n        delete idToFootprint[tokenId];\n        delete idToImprint[tokenId];\n        delete idToFirstTransfer[tokenId];\n        delete idToViewKey[tokenId];\n        delete idToTransferKey[tokenId];\n        delete tokenProviders[tokenId];\n\n        emit TokenBurned(tokenId);\n    }\n}\n",
    "@arianee/contracts/SmartAsset/SmartAssetRecoverable.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport \"./SmartAssetBase.sol\";\nimport \"../Utilities/BytesUtils.sol\";\n\n/**\n * @title SmartAssetRecoverable.\n * @author Arianee - Dynamic NFTs for real-world use cases and consumer engagement (www.arianee.org).\n */\nabstract contract SmartAssetRecoverable is SmartAssetBase {\n    /**\n     * @notice RECOVERER_ROLE: those who can validate a recovery request to return a token to the issuer.\n     */\n    bytes32 public constant RECOVERER_ROLE = keccak256(\"RECOVERER_ROLE\");\n\n    /**\n     * @notice HYDRATE_OTHER_PARAM_INDEX_TOKEN_URI: the index of recoveryWindowSec in the otherParams array of the hydrateToken function.\n     * NOTE: This index must be unique across all contracts that inherit from SmartAssetBase.\n     */\n    uint256 public constant HYDRATE_OTHER_PARAM_INDEX_RECOVERY_WINDOW_SEC = 1;\n\n    /**\n     * @notice Mapping from token id to a boolean indicating whether the token is waiting for recovery or not.\n     */\n    mapping(uint256 => bool) internal idToRecoveryRequest;\n\n    /**\n     * @notice Mapping from token id to the value of the recovery window in seconds.\n     */\n    mapping(uint256 => uint256) internal idToRecoveryWindowSec;\n\n    /**\n     * @notice Mapping from token id to the timestamp of the first transfer.\n     */\n    mapping(uint256 => uint256) internal idToFirstTransferTimestamp;\n\n    /**\n     * @notice This emits when a token recovery configuration is set.\n     */\n    event TokenRecoveryConfigured(uint256 indexed tokenId, uint256 recoveryWindowSec);\n\n    /**\n     * @notice This emits when a issuer request a token recovery.\n     */\n    event TokenRecoveryRequestUpdated(uint256 indexed tokenId, bool active);\n\n    /**\n     * @notice This emits when a token is recovered to the issuer.\n     */\n    event TokenRecovered(uint256 indexed tokenId);\n\n    constructor() {\n        _grantRole(RECOVERER_ROLE, msg.sender);\n    }\n\n    /**\n     * @notice Recover a token to the issuer without any recovery request.\n     * @dev This function can be used to recover a token only if the recovery window is not over.\n     * @param tokenId The token ID.\n     */\n    function recoverToken(uint256 tokenId) external isIssuer(tokenId) {\n        require(\n            block.timestamp <= (idToFirstTransferTimestamp[tokenId] + idToRecoveryWindowSec[tokenId]),\n            \"SmartAssetRecoverable: The token recovery window is over\"\n        );\n        _transferTokenToIssuer(tokenId);\n    }\n\n    /**\n     * @notice Validate a recovery request and transfer the token to the issuer.\n     * @param tokenId The token ID.\n     */\n    function validateRecoveryRequest(uint256 tokenId) external onlyRole(RECOVERER_ROLE) {\n        require(isWaitingForRecovery(tokenId), \"SmartAssetRecoverable: No active recovery request for this token\");\n\n        _transferTokenToIssuer(tokenId);\n        _updateRecoveryRequest(tokenId, false);\n    }\n\n    /**\n     * @notice Try to retrieve the recovery window and the first transfer timestamp of a token.\n     * @param tokenId The token ID.\n     * @return recoveryWindowSec The recovery window in seconds.\n     * @return firstTransferTimestamp The timestamp of the first transfer if any.\n     */\n    function recoveryWindowOf(\n        uint256 tokenId\n    ) external view returns (uint256 recoveryWindowSec, uint256 firstTransferTimestamp) {\n        return (idToRecoveryWindowSec[tokenId], idToFirstTransferTimestamp[tokenId]);\n    }\n\n    /**\n     * @notice Activate or deactivate a recovery request for a given token ID.\n     * @param tokenId The token ID.\n     * @param active A flag to indicate whether the recovery request is active or not.\n     */\n    function updateRecoveryRequest(uint256 tokenId, bool active) public isIssuer(tokenId) {\n        _updateRecoveryRequest(tokenId, active);\n    }\n\n    function _updateRecoveryRequest(uint256 tokenId, bool active) internal {\n        idToRecoveryRequest[tokenId] = active;\n        emit TokenRecoveryRequestUpdated(tokenId, active);\n    }\n\n    /**\n     * @notice See {SmartAssetBase-hydrateToken}\n     */\n    function hydrateToken(\n        TokenHydratationParams memory tokenHydratationParams\n    ) public virtual override onlyRole(MINTER_ROLE) whenNotPaused {\n        uint256 tokenId = tokenHydratationParams.tokenId;\n\n        require(tokenHydratationParams.otherParams.length > HYDRATE_OTHER_PARAM_INDEX_RECOVERY_WINDOW_SEC, \"SmartAssetRecoverable: HYDRATE_OTHER_PARAM_INDEX_RECOVERY_WINDOW_SEC is missing.\");\n        bytes memory recoveryWindowSecBytes = tokenHydratationParams.otherParams[\n            HYDRATE_OTHER_PARAM_INDEX_RECOVERY_WINDOW_SEC\n        ];\n        require(\n            recoveryWindowSecBytes.length > 0,\n            \"SmartAssetRecoverable: A non-zero uint256 is expected for the recoveryWindowSec argument.\"\n        );\n\n        uint256 recoveryWindowSec = BytesLib.toUint256(recoveryWindowSecBytes, 0);\n\n        idToRecoveryWindowSec[tokenId] = recoveryWindowSec;\n        emit TokenRecoveryConfigured(tokenId, recoveryWindowSec);\n\n        super.hydrateToken(tokenHydratationParams);\n    }\n\n    /**\n     * @notice Check whether a token is waiting for recovery or not.\n     * @param tokenId The token ID.\n     * @return A boolean indicating whether the token is waiting for recovery or not.\n     */\n    function isWaitingForRecovery(uint256 tokenId) public view returns (bool) {\n        return idToRecoveryRequest[tokenId];\n    }\n\n    /**\n     * @notice Transfer the token to the issuer.\n     * NOTE: This function does not perform any check.\n     */\n    function _transferTokenToIssuer(uint256 tokenId) internal {\n        super._approve(_msgSender(), tokenId);\n\n        address owner = super.ownerOf(tokenId);\n        address issuer = super.footprintOf(tokenId).issuer;\n        super.safeTransferFrom(owner, issuer, tokenId);\n\n        emit TokenRecovered(tokenId);\n    }\n\n    /**\n     * @dev See {SmartAssetBase-_afterFirstTokenTransfer}.\n     */\n    function _afterFirstTokenTransfer(uint256 tokenId) internal virtual override {\n        idToFirstTransferTimestamp[tokenId] = block.timestamp;\n        super._afterFirstTokenTransfer(tokenId);\n    }\n\n    /**\n     * @dev See {ERC721-_burn}.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        delete idToRecoveryRequest[tokenId];\n        delete idToRecoveryWindowSec[tokenId];\n        delete idToFirstTransferTimestamp[tokenId];\n    }\n}\n",
    "@arianee/contracts/SmartAsset/SmartAssetSoulbound.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport \"./SmartAssetBase.sol\";\n\n/**\n * @title SmartAssetSoulbound.\n * @author Arianee - Dynamic NFTs for real-world use cases and consumer engagement (www.arianee.org).\n */\nabstract contract SmartAssetSoulbound is SmartAssetBase {\n    /**\n     * @dev See {SmartAssetBase-requestToken}.\n     */\n    function requestToken(\n        uint256 tokenId,\n        bytes calldata signature,\n        address newOwner,\n        bool keepTransferKey,\n        address walletProvider\n    ) public virtual override whenNotPaused {\n        require(keepTransferKey == false, \"SmartAssetSoulbound: Forbidden to keep the transfer key\");\n        super.requestToken(tokenId, signature, newOwner, keepTransferKey, walletProvider);\n    }\n\n    /**\n     * @dev See {SmartAssetBase-setTokenTransferKey}.\n     */\n    function setTokenTransferKey(\n        uint256 tokenId,\n        address key\n    ) public virtual override isApprovedOrOwner(_msgSender(), tokenId) whenNotPaused {\n        address owner = super.ownerOf(tokenId);\n        address issuer = super.footprintOf(tokenId).issuer;\n        require(owner == issuer, \"SmartAssetSoulbound: Only the issuer can set the transfer key\");\n\n        super.setTokenTransferKey(tokenId, key);\n    }\n\n    /**\n     * @dev See {SmartAssetBase-_transfer}\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual override {\n        address owner = super.ownerOf(tokenId);\n        address issuer = super.footprintOf(tokenId).issuer;\n\n        // If the owner is NOT the issuer, the token is soulbound and the transfer can be made only by the issuer to change the owner if needed\n        if (owner != issuer) {\n            require(issuer == _msgSender(), \"SmartAssetSoulbound: Only the issuer can transfer the token\");\n        }\n\n        /**\n         * If the previous condition has not been hit, the owner IS the issuer and the token is not soulbound yet or not anymore for a limited time.\n         * This is either the first transfer of the token to its first \"real\" owner or a recovery request made by the issuer on the behalf of the owner (i.e the owner lost his wallet and wants to recover his token)\n         */\n\n        super._transfer(from, to, tokenId);\n    }\n}\n",
    "@arianee/contracts/SmartAsset/SmartAssetUpdatable.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport \"./SmartAssetBase.sol\";\n\n/**\n * @title SmartAssetUpdatable.\n * @author Arianee - Dynamic NFTs for real-world use cases and consumer engagement (www.arianee.org).\n */\nabstract contract SmartAssetUpdatable is SmartAssetBase {\n    /**\n     * @notice Update of a token.\n     */\n    struct TokenUpdate {\n        bytes32 imprint;\n        uint256 updateTimestamp;\n    }\n\n    /**\n     * @notice Mapping from token id to its last update.\n     */\n    mapping(uint256 => TokenUpdate) internal idToLastUpdate;\n\n    /**\n     * @notice This emits when a token is updated.\n     */\n    event TokenUpdated(uint256 indexed tokenId, bytes32 indexed imprint);\n\n    /**\n     * Update a token imprint.\n     * @param tokenId The token ID.\n     * @param newImprint The new token imprint.\n     */\n    function updateToken(uint256 tokenId, bytes32 newImprint) external isIssuer(tokenId) {\n        _requireMinted(tokenId);\n\n        idToLastUpdate[tokenId] = TokenUpdate({imprint: newImprint, updateTimestamp: block.timestamp});\n        emit TokenUpdated(tokenId, newImprint);\n    }\n\n    /**\n     * @notice Try to retrieve the last update of a given token.\n     * @dev Throws if the token is not minted.\n     * @param tokenId The token ID.\n     * @return The last update of the token if any.\n     */\n    function getLastUpdateOf(uint256 tokenId) public view returns (TokenUpdate memory) {\n        _requireMinted(tokenId);\n        return idToLastUpdate[tokenId];\n    }\n\n    /**\n     * @notice Try to retrieve the last imprint of a given token.\n     * @dev If the token has never been updated, the original imprint is returned.\n     * @param tokenId The token ID.\n     * @return The last imprint of the token.\n     */\n    function getLastImprintOf(uint256 tokenId) public view returns (bytes32) {\n        TokenUpdate memory lastUpdate = getLastUpdateOf(tokenId);\n        if (lastUpdate.updateTimestamp == 0) {\n            return super.imprintOf(tokenId);\n        } else {\n            return lastUpdate.imprint;\n        }\n    }\n}\n",
    "@arianee/contracts/SmartAsset/SmartAssetURIStorage.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport \"./SmartAssetBase.sol\";\n\n/**\n * @title SmartAssetURIStorage.\n * @author Arianee - Dynamic NFTs for real-world use cases and consumer engagement (www.arianee.org).\n */\nabstract contract SmartAssetURIStorage is SmartAssetBase {\n    /**\n     * @notice Base URI for computing {tokenURI}.\n     */\n    string public baseURI = \"\";\n\n    /**\n     * @notice This emits when the base URI is updated.\n     */\n    event SetNewBaseURI(string newBaseURI);\n\n    constructor(string memory baseURI_) {\n        setBaseURI(baseURI_);\n    }\n\n    /**\n     * @notice Set the base URI for all smart assets. It is automatically added as a prefix to the value returned in {ERC721-tokenURI}.\n     * @param newBaseURI The new base URI.\n     */\n    function setBaseURI(string memory newBaseURI) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        baseURI = newBaseURI;\n        emit SetNewBaseURI(newBaseURI);\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseURI;\n    }\n}\n",
    "@arianee/contracts/SmartAsset/SmartAssetURIStorageOverridable.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport \"./SmartAssetURIStorage.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\n\n/**\n * @title SmartAssetURIStorageOverridable.\n * @author Arianee - Dynamic NFTs for real-world use cases and consumer engagement (www.arianee.org).\n */\nabstract contract SmartAssetURIStorageOverridable is SmartAssetURIStorage, ERC721URIStorage {\n    /**\n     * @notice HYDRATE_OTHER_PARAM_INDEX_TOKEN_URI: the index of tokenURI in the otherParams array of the hydrateToken function.\n     * NOTE: This index must be unique across all contracts that inherit from SmartAssetBase.\n     */\n    uint256 public constant HYDRATE_OTHER_PARAM_INDEX_TOKEN_URI = 0;\n\n    /**\n     * @notice This emits when a smart asset's URI is updated.\n     */\n    event TokenURIUpdated(uint256 indexed tokenId, string newURI);\n\n    constructor(string memory baseURI_) SmartAssetURIStorage(baseURI_) {}\n\n    /**\n     * @notice Set the URI for a given token ID.\n     * @param newTokenURI The new token URI.\n     */\n    function setTokenURI(uint256 tokenId, string memory newTokenURI) public isIssuer(tokenId) {\n        super._setTokenURI(tokenId, newTokenURI);\n        emit TokenURIUpdated(tokenId, tokenURI(tokenId));\n    }\n\n    /**\n     * @dev See {SmartAssetBase-hydrateToken}\n     */\n    function hydrateToken(\n        TokenHydratationParams memory tokenHydratationParams\n    ) public virtual override onlyRole(MINTER_ROLE) whenNotPaused {\n        uint256 tokenId = tokenHydratationParams.tokenId;\n\n        require(tokenHydratationParams.otherParams.length > HYDRATE_OTHER_PARAM_INDEX_TOKEN_URI, \"SmartAssetRecoverable: HYDRATE_OTHER_PARAM_INDEX_TOKEN_URI is missing.\");\n        bytes memory newTokenURIBytes = tokenHydratationParams.otherParams[HYDRATE_OTHER_PARAM_INDEX_TOKEN_URI];\n        string memory newTokenURI = string(newTokenURIBytes);\n\n        super.hydrateToken(tokenHydratationParams);\n        setTokenURI(tokenId, newTokenURI);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override(ERC721URIStorage, ERC721) returns (string memory) {\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(SmartAssetBase, ERC721) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {ERC721-_burn}.\n     */\n    function _burn(uint256 tokenId) internal virtual override(ERC721URIStorage, ERC721) {\n        super._burn(tokenId);\n    }\n\n    /**\n     * @dev See {SmartAssetBase-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 batchSize\n    ) internal virtual override(SmartAssetBase, ERC721) whenNotPaused {\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n\n    /**\n     * @dev See {SmartAssetBase-_transfer}.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual override(SmartAssetBase, ERC721) {\n        super._transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {SmartAssetURIStorage-_baseURI}\n     */\n    function _baseURI() internal view virtual override(SmartAssetURIStorage, ERC721) returns (string memory) {\n        return super._baseURI();\n    }\n\n    /**\n     * @dev See {SmartAssetBase-_afterTokenTransfer}.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 batchSize\n    ) internal virtual override(SmartAssetBase, ERC721) {\n        SmartAssetBase._afterTokenTransfer(from, to, tokenId, batchSize);\n    }\n\n    /**\n     * @dev See {SmartAssetBase-_msgSender}.\n     */\n    function _msgSender() internal view virtual override(SmartAssetBase, Context) returns (address) {\n        return SmartAssetBase._msgSender();\n    }\n\n    /**\n     * @dev See {SmartAssetBase-_msgData}.\n     */\n    function _msgData() internal view virtual override(SmartAssetBase, Context) returns (bytes calldata) {\n        return SmartAssetBase._msgData();\n    }\n}\n",
    "@arianee/contracts/Utilities/BytesUtils.sol": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n * The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1, \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {\n\n                        } eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n",
    "@arianee/contracts/Utilities/MutableERC2771Context.sol": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title MutableERC2771Context\n * @notice Context variant with ERC2771 support (with mutable `_trustedForwarder`).\n * @dev Based on OpenZeppelin ERC2771Context contract.\n */\nabstract contract MutableERC2771Context is Context, Ownable {\n    address private _trustedForwarder;\n\n    event TrustedForwarderSet(address indexed previousForwarder, address indexed newForwarder);\n\n    constructor(address trustedForwarder_) {\n        _setTrustedForwarder(trustedForwarder_);\n    }\n\n    function setTrustedForwarder(address trustedForwarder) external virtual onlyOwner {\n        _setTrustedForwarder(trustedForwarder);\n    }\n\n    function _setTrustedForwarder(address trustedForwarder) internal virtual {\n        address previousForwarder = _trustedForwarder;\n        _trustedForwarder = trustedForwarder;\n        emit TrustedForwarderSet(previousForwarder, trustedForwarder);\n    }\n\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == _trustedForwarder;\n    }\n\n    function _msgSender() internal view virtual override returns (address sender) {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            /// @solidity memory-safe-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return super._msgData();\n        }\n    }\n}\n"
  },
  "dependencies": {
    "@arianee/contracts/Interfaces/ICreditManager.sol": [],
    "@arianee/contracts/Interfaces/IRulesManager.sol": [],
    "@arianee/contracts/SmartAsset/SmartAssetBase.sol": [
      "@openzeppelin/contracts/security/Pausable.sol",
      "@openzeppelin/contracts/access/Ownable.sol",
      "@openzeppelin/contracts/access/AccessControl.sol",
      "@openzeppelin/contracts/token/ERC721/ERC721.sol",
      "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol",
      "@arianee/contracts/Utilities/MutableERC2771Context.sol",
      "@openzeppelin/contracts/utils/cryptography/ECDSA.sol",
      "@arianee/contracts/Interfaces/ICreditManager.sol",
      "@arianee/contracts/Interfaces/IRulesManager.sol",
      "@openzeppelin/contracts/utils/Context.sol"
    ],
    "@arianee/contracts/SmartAsset/SmartAssetBurnable.sol": [
      "@arianee/contracts/SmartAsset/SmartAssetBase.sol",
      "@openzeppelin/contracts/security/Pausable.sol",
      "@openzeppelin/contracts/access/Ownable.sol",
      "@openzeppelin/contracts/access/AccessControl.sol",
      "@openzeppelin/contracts/token/ERC721/ERC721.sol",
      "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol",
      "@arianee/contracts/Utilities/MutableERC2771Context.sol",
      "@openzeppelin/contracts/utils/cryptography/ECDSA.sol",
      "@arianee/contracts/Interfaces/ICreditManager.sol",
      "@arianee/contracts/Interfaces/IRulesManager.sol",
      "@openzeppelin/contracts/utils/Context.sol"
    ],
    "@arianee/contracts/SmartAsset/SmartAssetRecoverable.sol": [
      "@arianee/contracts/SmartAsset/SmartAssetBase.sol",
      "@arianee/contracts/Utilities/BytesUtils.sol",
      "@openzeppelin/contracts/security/Pausable.sol",
      "@openzeppelin/contracts/access/Ownable.sol",
      "@openzeppelin/contracts/access/AccessControl.sol",
      "@openzeppelin/contracts/token/ERC721/ERC721.sol",
      "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol",
      "@arianee/contracts/Utilities/MutableERC2771Context.sol",
      "@openzeppelin/contracts/utils/cryptography/ECDSA.sol",
      "@arianee/contracts/Interfaces/ICreditManager.sol",
      "@arianee/contracts/Interfaces/IRulesManager.sol",
      "@openzeppelin/contracts/utils/Context.sol"
    ],
    "@arianee/contracts/SmartAsset/SmartAssetSoulbound.sol": [
      "@arianee/contracts/SmartAsset/SmartAssetBase.sol",
      "@openzeppelin/contracts/security/Pausable.sol",
      "@openzeppelin/contracts/access/Ownable.sol",
      "@openzeppelin/contracts/access/AccessControl.sol",
      "@openzeppelin/contracts/token/ERC721/ERC721.sol",
      "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol",
      "@arianee/contracts/Utilities/MutableERC2771Context.sol",
      "@openzeppelin/contracts/utils/cryptography/ECDSA.sol",
      "@arianee/contracts/Interfaces/ICreditManager.sol",
      "@arianee/contracts/Interfaces/IRulesManager.sol",
      "@openzeppelin/contracts/utils/Context.sol"
    ],
    "@arianee/contracts/SmartAsset/SmartAssetURIStorage.sol": [
      "@arianee/contracts/SmartAsset/SmartAssetBase.sol",
      "@openzeppelin/contracts/security/Pausable.sol",
      "@openzeppelin/contracts/access/Ownable.sol",
      "@openzeppelin/contracts/access/AccessControl.sol",
      "@openzeppelin/contracts/token/ERC721/ERC721.sol",
      "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol",
      "@arianee/contracts/Utilities/MutableERC2771Context.sol",
      "@openzeppelin/contracts/utils/cryptography/ECDSA.sol",
      "@arianee/contracts/Interfaces/ICreditManager.sol",
      "@arianee/contracts/Interfaces/IRulesManager.sol",
      "@openzeppelin/contracts/utils/Context.sol"
    ],
    "@arianee/contracts/SmartAsset/SmartAssetURIStorageOverridable.sol": [
      "@arianee/contracts/SmartAsset/SmartAssetURIStorage.sol",
      "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol",
      "@arianee/contracts/SmartAsset/SmartAssetBase.sol",
      "@openzeppelin/contracts/security/Pausable.sol",
      "@openzeppelin/contracts/access/Ownable.sol",
      "@openzeppelin/contracts/access/AccessControl.sol",
      "@openzeppelin/contracts/token/ERC721/ERC721.sol",
      "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol",
      "@arianee/contracts/Utilities/MutableERC2771Context.sol",
      "@openzeppelin/contracts/utils/cryptography/ECDSA.sol",
      "@arianee/contracts/Interfaces/ICreditManager.sol",
      "@arianee/contracts/Interfaces/IRulesManager.sol",
      "@openzeppelin/contracts/utils/Context.sol"
    ],
    "@arianee/contracts/SmartAsset/SmartAssetUpdatable.sol": [
      "@arianee/contracts/SmartAsset/SmartAssetBase.sol",
      "@openzeppelin/contracts/security/Pausable.sol",
      "@openzeppelin/contracts/access/Ownable.sol",
      "@openzeppelin/contracts/access/AccessControl.sol",
      "@openzeppelin/contracts/token/ERC721/ERC721.sol",
      "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol",
      "@arianee/contracts/Utilities/MutableERC2771Context.sol",
      "@openzeppelin/contracts/utils/cryptography/ECDSA.sol",
      "@arianee/contracts/Interfaces/ICreditManager.sol",
      "@arianee/contracts/Interfaces/IRulesManager.sol",
      "@openzeppelin/contracts/utils/Context.sol"
    ],
    "@arianee/contracts/Utilities/BytesUtils.sol": [],
    "@arianee/contracts/Utilities/MutableERC2771Context.sol": [
      "@openzeppelin/contracts/utils/Context.sol",
      "@openzeppelin/contracts/access/Ownable.sol"
    ]
  }
}